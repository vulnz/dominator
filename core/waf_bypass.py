"""
WAF/Cloudflare Bypass Module

Provides multiple strategies for bypassing WAF protections:
1. cloudscraper - JavaScript challenge solving (lightweight, fast)
2. Browser headers - Realistic browser fingerprinting
3. Playwright - Full headless browser (heavy, for complex challenges)

Requirements:
    pip install cloudscraper  # Primary method
    pip install playwright && playwright install chromium  # Fallback for complex cases
"""

import logging
from typing import Optional, Dict, Any, List, Tuple
from dataclasses import dataclass
import time
import re

logger = logging.getLogger(__name__)

# Try to import cloudscraper (primary WAF bypass)
CLOUDSCRAPER_AVAILABLE = False
try:
    import cloudscraper
    CLOUDSCRAPER_AVAILABLE = True
except ImportError:
    logger.debug("cloudscraper not installed. Install with: pip install cloudscraper")

# Try to import playwright (heavy fallback)
PLAYWRIGHT_AVAILABLE = False
try:
    from core.browser_engine import SyncHeadlessBrowser, is_browser_available
    PLAYWRIGHT_AVAILABLE = is_browser_available()
except ImportError:
    pass


@dataclass
class WAFInfo:
    """Information about detected WAF"""
    detected: bool
    waf_type: str = ""
    confidence: float = 0.0
    bypass_available: bool = False
    bypass_method: str = ""
    details: str = ""


class WAFDetector:
    """Detect WAF/Cloudflare protection on target"""

    # Known WAF signatures
    WAF_SIGNATURES = {
        'cloudflare': {
            'headers': ['cf-ray', 'cf-cache-status', '__cfduid', 'cf-request-id'],
            'content': ['cloudflare', 'cf-browser-verification', 'checking your browser',
                       'ddos protection by cloudflare', 'cf-turnstile'],
            'cookies': ['__cf_bm', 'cf_clearance', '__cfduid'],
        },
        'akamai': {
            'headers': ['x-akamai-transformed', 'akamai-origin-hop'],
            'content': ['akamai', 'access denied - akamai'],
            'cookies': ['ak_bmsc', 'bm_sv'],
        },
        'incapsula': {
            'headers': ['x-iinfo', 'x-cdn'],
            'content': ['incapsula', 'imperva', 'blocked by incapsula'],
            'cookies': ['incap_ses', 'visid_incap'],
        },
        'sucuri': {
            'headers': ['x-sucuri-id', 'x-sucuri-cache'],
            'content': ['sucuri website firewall', 'sucuri cloudproxy'],
            'cookies': [],
        },
        'aws_waf': {
            'headers': ['x-amzn-requestid', 'x-amz-cf-id'],
            'content': ['aws waf', 'request blocked'],
            'cookies': ['awswaf'],
        },
        'modsecurity': {
            'headers': ['server: apache', 'x-mod-security'],
            'content': ['mod_security', 'request blocked', 'not acceptable'],
            'cookies': [],
        },
        'f5_big-ip': {
            'headers': ['x-wa-info', 'server: bigip'],
            'content': ['f5 networks', 'request rejected'],
            'cookies': ['ts', 'bigipserver'],
        },
        'wordfence': {
            'headers': [],
            'content': ['wordfence', 'blocked by wordfence', 'generated by wordfence'],
            'cookies': ['wfvt_', 'wordfence'],
        },
        'generic': {
            'headers': [],
            'content': ['access denied', 'forbidden', 'blocked', 'security check',
                       'bot detected', 'automated access'],
            'cookies': [],
        },
    }

    @classmethod
    def detect(cls, headers: Dict[str, str], content: str,
               cookies: List[str] = None, status_code: int = 200) -> WAFInfo:
        """
        Detect WAF from response

        Args:
            headers: Response headers (dict or dict-like)
            content: Response body text
            cookies: List of cookie names
            status_code: HTTP status code

        Returns:
            WAFInfo with detection results
        """
        headers_lower = {k.lower(): v.lower() for k, v in headers.items()}
        content_lower = content.lower() if content else ""
        cookies = cookies or []

        # Check if response indicates blocking
        is_blocked = status_code in [403, 503, 429] or any(
            phrase in content_lower for phrase in
            ['access denied', 'blocked', 'forbidden', 'please wait', 'checking your browser']
        )

        for waf_name, signatures in cls.WAF_SIGNATURES.items():
            confidence = 0.0
            matches = []

            # Check headers
            for header in signatures['headers']:
                if header.lower() in headers_lower:
                    confidence += 0.3
                    matches.append(f"header:{header}")

            # Check content
            for pattern in signatures['content']:
                if pattern.lower() in content_lower:
                    confidence += 0.25
                    matches.append(f"content:{pattern[:20]}")

            # Check cookies
            for cookie in signatures['cookies']:
                if any(cookie.lower() in c.lower() for c in cookies):
                    confidence += 0.2
                    matches.append(f"cookie:{cookie}")

            # If blocked, boost confidence
            if is_blocked and matches:
                confidence += 0.25

            if confidence >= 0.5:
                # Determine bypass method
                bypass_available = False
                bypass_method = ""

                if waf_name == 'cloudflare':
                    if CLOUDSCRAPER_AVAILABLE:
                        bypass_available = True
                        bypass_method = "cloudscraper"
                    elif PLAYWRIGHT_AVAILABLE:
                        bypass_available = True
                        bypass_method = "playwright"
                elif CLOUDSCRAPER_AVAILABLE:
                    bypass_available = True
                    bypass_method = "cloudscraper"

                return WAFInfo(
                    detected=True,
                    waf_type=waf_name.replace('_', ' ').title(),
                    confidence=min(confidence, 1.0),
                    bypass_available=bypass_available,
                    bypass_method=bypass_method,
                    details=f"Matched: {', '.join(matches[:3])}"
                )

        # No specific WAF detected but might be blocked
        if is_blocked:
            return WAFInfo(
                detected=True,
                waf_type="Unknown/Generic",
                confidence=0.5,
                bypass_available=CLOUDSCRAPER_AVAILABLE or PLAYWRIGHT_AVAILABLE,
                bypass_method="cloudscraper" if CLOUDSCRAPER_AVAILABLE else "playwright",
                details="Blocked response detected (403/503/429)"
            )

        return WAFInfo(detected=False)


class CloudscraperClient:
    """
    Cloudscraper-based HTTP client for WAF bypass

    Usage:
        client = CloudscraperClient()
        response = client.get("https://cloudflare-protected-site.com")
    """

    def __init__(self, proxy: str = None, timeout: int = 30,
                 browser: str = 'chrome', delay: float = 0):
        """
        Initialize cloudscraper client

        Args:
            proxy: Proxy URL (e.g., http://127.0.0.1:8080)
            timeout: Request timeout in seconds
            browser: Browser to emulate ('chrome' or 'firefox')
            delay: Delay between requests (WAF evasion)
        """
        if not CLOUDSCRAPER_AVAILABLE:
            raise ImportError(
                "cloudscraper is required for WAF bypass.\n"
                "Install with: pip install cloudscraper"
            )

        self.timeout = timeout
        self.delay = delay
        self.last_request_time = 0

        # Create scraper with browser emulation
        self.scraper = cloudscraper.create_scraper(
            browser={
                'browser': browser,
                'platform': 'windows',
                'mobile': False
            },
            delay=delay,
            disableCloudflareV1=False
        )

        # Note: SSL verification must remain enabled for cloudscraper to work
        # on Python 3.14+ due to stricter SSL requirements

        # Set proxy if provided
        if proxy:
            self.scraper.proxies = {
                'http': proxy,
                'https': proxy
            }

        # Set timeout
        self.scraper.timeout = timeout

    def get(self, url: str, **kwargs) -> Optional[Any]:
        """
        Make GET request with WAF bypass

        Args:
            url: URL to request
            **kwargs: Additional request arguments

        Returns:
            Response object or None on error
        """
        # Apply delay if configured
        if self.delay > 0:
            elapsed = time.time() - self.last_request_time
            if elapsed < self.delay:
                time.sleep(self.delay - elapsed)

        try:
            kwargs.setdefault('timeout', self.timeout)
            # Note: Don't set verify=False on Python 3.14+ (causes SSL errors)

            response = self.scraper.get(url, **kwargs)
            self.last_request_time = time.time()

            return response

        except cloudscraper.exceptions.CloudflareChallengeError as e:
            logger.warning(f"Cloudflare challenge failed: {e}")
            return None
        except Exception as e:
            logger.error(f"Request error: {e}")
            return None

    def post(self, url: str, data: Dict = None, **kwargs) -> Optional[Any]:
        """Make POST request with WAF bypass"""
        try:
            kwargs.setdefault('timeout', self.timeout)
            # Note: Don't set verify=False on Python 3.14+ (causes SSL errors)
            return self.scraper.post(url, data=data, **kwargs)
        except Exception as e:
            logger.error(f"POST error: {e}")
            return None


class WAFBypass:
    """
    Unified WAF bypass interface

    Automatically selects best available method:
    1. cloudscraper (preferred - fast, lightweight)
    2. Playwright headless browser (fallback - heavy)
    3. Standard requests with enhanced headers (last resort)
    """

    def __init__(self, proxy: str = None, timeout: int = 30,
                 prefer_browser: bool = False):
        """
        Initialize WAF bypass

        Args:
            proxy: Proxy URL
            timeout: Request timeout
            prefer_browser: Force use of headless browser
        """
        self.proxy = proxy
        self.timeout = timeout
        self.prefer_browser = prefer_browser

        self._cloudscraper = None
        self._browser = None
        self._method = None

        # Select best available method
        if prefer_browser and PLAYWRIGHT_AVAILABLE:
            self._method = 'playwright'
        elif CLOUDSCRAPER_AVAILABLE:
            self._method = 'cloudscraper'
        elif PLAYWRIGHT_AVAILABLE:
            self._method = 'playwright'
        else:
            self._method = 'requests'

        logger.info(f"WAF bypass using: {self._method}")

    def _get_client(self):
        """Get or create the appropriate client"""
        if self._method == 'cloudscraper':
            if not self._cloudscraper:
                self._cloudscraper = CloudscraperClient(
                    proxy=self.proxy,
                    timeout=self.timeout
                )
            return self._cloudscraper

        elif self._method == 'playwright':
            if not self._browser:
                from core.browser_engine import SyncHeadlessBrowser
                self._browser = SyncHeadlessBrowser(
                    headless=True,
                    timeout=self.timeout * 1000,
                    proxy=self.proxy
                )
            return self._browser

        return None

    def get(self, url: str, **kwargs) -> Optional[Any]:
        """
        Make GET request with automatic WAF bypass

        Args:
            url: URL to request
            **kwargs: Additional request arguments

        Returns:
            Response object
        """
        client = self._get_client()

        if self._method == 'cloudscraper':
            return client.get(url, **kwargs)

        elif self._method == 'playwright':
            response = client.get(url)
            if response:
                # Wrap in requests-like response
                class BrowserResponse:
                    def __init__(self, r):
                        self.status_code = r.status_code
                        self.text = r.text
                        self.content = r.text.encode()
                        self.headers = r.headers
                        self.url = r.final_url
                        self.cookies = r.cookies

                    @property
                    def ok(self):
                        return 200 <= self.status_code < 400

                return BrowserResponse(response)

        # Fallback to standard requests with enhanced headers
        import requests
        headers = kwargs.get('headers', {})
        headers.setdefault('User-Agent',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 '
            '(KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36')
        headers.setdefault('Accept',
            'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8')
        headers.setdefault('Accept-Language', 'en-US,en;q=0.9')
        kwargs['headers'] = headers
        kwargs.setdefault('timeout', self.timeout)
        kwargs.setdefault('verify', False)

        return requests.get(url, **kwargs)

    def close(self):
        """Clean up resources"""
        if self._browser:
            try:
                self._browser.close()
            except:
                pass

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()


def check_waf_and_suggest(url: str, headers: Dict = None) -> Tuple[WAFInfo, str]:
    """
    Check URL for WAF and suggest bypass method

    Args:
        url: Target URL to check
        headers: Optional custom headers

    Returns:
        Tuple of (WAFInfo, suggestion_message)
    """
    import requests

    # Make initial request with browser headers
    request_headers = headers or {}
    request_headers.setdefault('User-Agent',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 '
        '(KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36')

    try:
        response = requests.get(url, headers=request_headers,
                               timeout=15, verify=False, allow_redirects=True)

        # Get cookies from response
        cookies = list(response.cookies.keys())

        # Detect WAF
        waf_info = WAFDetector.detect(
            headers=dict(response.headers),
            content=response.text,
            cookies=cookies,
            status_code=response.status_code
        )

        # Build suggestion message
        if waf_info.detected:
            msg = f"\n{'='*60}\n"
            msg += f"WAF DETECTED: {waf_info.waf_type}\n"
            msg += f"Confidence: {waf_info.confidence*100:.0f}%\n"
            msg += f"Details: {waf_info.details}\n"

            if waf_info.bypass_available:
                msg += f"\nBypass Available: Yes (using {waf_info.bypass_method})\n"
                if waf_info.bypass_method == 'cloudscraper':
                    msg += "Recommendation: Run with --waf-mode flag for automatic bypass\n"
                else:
                    msg += "Recommendation: Run with --browser flag for headless browser bypass\n"
            else:
                msg += "\nBypass Available: No\n"
                if not CLOUDSCRAPER_AVAILABLE:
                    msg += "Install cloudscraper for bypass: pip install cloudscraper\n"
                if not PLAYWRIGHT_AVAILABLE:
                    msg += "Or install playwright: pip install playwright && playwright install chromium\n"

            msg += f"{'='*60}\n"
        else:
            msg = "No WAF detected - proceeding with normal requests"

        return waf_info, msg

    except Exception as e:
        return WAFInfo(detected=False), f"Could not check WAF: {e}"


def get_bypass_client(waf_info: WAFInfo = None, proxy: str = None,
                      timeout: int = 30) -> Any:
    """
    Get appropriate client for WAF bypass

    Args:
        waf_info: Optional WAF detection info
        proxy: Proxy URL
        timeout: Request timeout

    Returns:
        HTTP client with WAF bypass capability
    """
    if waf_info and waf_info.bypass_available:
        if waf_info.bypass_method == 'cloudscraper' and CLOUDSCRAPER_AVAILABLE:
            return CloudscraperClient(proxy=proxy, timeout=timeout)
        elif waf_info.bypass_method == 'playwright' and PLAYWRIGHT_AVAILABLE:
            from core.browser_engine import SyncHeadlessBrowser
            return SyncHeadlessBrowser(headless=True, timeout=timeout*1000, proxy=proxy)

    # Default to WAFBypass which auto-selects
    return WAFBypass(proxy=proxy, timeout=timeout)


def is_bypass_available() -> bool:
    """Check if any WAF bypass method is available"""
    return CLOUDSCRAPER_AVAILABLE or PLAYWRIGHT_AVAILABLE


def get_install_instructions() -> str:
    """Get installation instructions for WAF bypass"""
    return """
WAF Bypass requires one of:

1. cloudscraper (Recommended - fast and lightweight):
   pip install cloudscraper

2. Playwright (For complex challenges):
   pip install playwright
   playwright install chromium

After installation, use --waf-mode flag to enable automatic bypass.
"""

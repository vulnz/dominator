"""
Main vulnerability scanner orchestrator - refactored and modular
"""

from typing import List, Dict, Any
import time
from core.http_client import HTTPClient
from core.result_manager import ResultManager
from core.report_generator import ReportGenerator
from core.crawler import WebCrawler
from core.url_parser import URLParser
from core.logger import get_logger
from scanners.injection_scanner import InjectionScanner
from scanners.file_scanner import FileScanner
from scanners.config_scanner import ConfigScanner

logger = get_logger(__name__)


class VulnerabilityScanner:
    """Main vulnerability scanner orchestrator"""

    def __init__(self, config):
        """
        Initialize vulnerability scanner

        Args:
            config: Scanner configuration
        """
        self.config = config
        self.stop_requested = False

        # Initialize HTTP client
        # FIXED: Added proxy support for Burp/ZAP integration
        self.http_client = HTTPClient(
            timeout=config.timeout,
            headers=config.headers,
            cookies=config.cookies,
            rate_limit=config.request_limit,
            proxy=config.proxy
        )

        # Initialize result manager
        self.result_manager = ResultManager()

        # Initialize crawler
        self.crawler = WebCrawler(config, self.http_client)

        # Initialize URL parser
        self.url_parser = URLParser()

        # Initialize scanners
        self.scanners = []
        if self._has_injection_modules():
            self.scanners.append(InjectionScanner(self.http_client, config))
        if self._has_file_modules():
            self.scanners.append(FileScanner(self.http_client, config))
        if self._has_config_modules():
            self.scanners.append(ConfigScanner(self.http_client, config))

        # Initialize report generator
        self.report_generator = ReportGenerator()

        logger.info(f"Scanner initialized with {len(self.scanners)} scanner modules")

    def _has_injection_modules(self) -> bool:
        """Check if any injection modules are enabled"""
        injection_modules = {'xss', 'sqli', 'commandinjection', 'ldapinjection',
                           'nosqlinjection', 'ssti', 'xxe', 'crlf', 'textinjection',
                           'htmlinjection'}
        return bool(injection_modules & set(self.config.modules))

    def _has_file_modules(self) -> bool:
        """Check if any file modules are enabled"""
        file_modules = {'lfi', 'rfi', 'dirtraversal', 'pathtraversal'}
        return bool(file_modules & set(self.config.modules))

    def _has_config_modules(self) -> bool:
        """Check if any config modules are enabled"""
        config_modules = {'dirbrute', 'git', 'phpinfo', 'secheaders', 'ssltls'}
        return bool(config_modules & set(self.config.modules))

    def scan(self) -> List[Dict[str, Any]]:
        """
        Run vulnerability scan

        Returns:
            List of scan results
        """
        logger.info("Starting vulnerability scan")
        start_time = time.time()

        # Get targets
        targets = self.config.get_targets()
        if not targets:
            logger.error("No targets specified")
            return []

        logger.info(f"Scanning {len(targets)} target(s)")

        all_results = []

        for target in targets:
            if self.stop_requested:
                logger.warning("Scan stopped by user request")
                break

            logger.info(f"Scanning target: {target}")

            # Discover pages and endpoints
            discovered_urls = self._discover_pages(target)
            logger.info(f"Discovered {len(discovered_urls)} URLs for {target}")

            # Run scanners
            for scanner in self.scanners:
                if self.stop_requested:
                    break

                logger.info(f"Running {scanner.get_name()} scanner")
                try:
                    scanner_results = scanner.scan(discovered_urls)
                    all_results.extend(scanner_results)
                    self.result_manager.add_results(scanner_results)
                    logger.info(f"{scanner.get_name()} found {len(scanner_results)} results")
                except Exception as e:
                    logger.error(f"Error in {scanner.get_name()} scanner: {e}")

        duration = time.time() - start_time
        logger.info(f"Scan completed in {duration:.2f} seconds")

        # Print statistics
        stats = self.result_manager.get_statistics()
        logger.info(f"Total results: {stats['total_results']}")
        logger.info(f"Total vulnerabilities: {stats['total_vulnerabilities']}")

        return all_results

    def _discover_pages(self, target: str) -> List[Dict[str, Any]]:
        """
        Discover pages and endpoints

        Args:
            target: Target URL

        Returns:
            List of discovered URLs with parameters
        """
        discovered = []

        # If single URL mode, just parse the target
        if self.config.single_url:
            parsed = self.url_parser.parse_url(target)
            if parsed:
                discovered.append(parsed)
            return discovered

        # Otherwise, crawl the target
        try:
            pages = self.crawler.crawl_for_pages(target)

            for page in pages:
                parsed = self.url_parser.parse_url(page)
                if parsed:
                    discovered.append(parsed)

            logger.info(f"Parsed {len(discovered)} URLs with parameters")

        except Exception as e:
            logger.error(f"Error during page discovery: {e}")

        return discovered

    def print_results(self, results: List[Dict[str, Any]]):
        """
        Print scan results to console

        Args:
            results: List of scan results
        """
        self.result_manager.print_summary()

        # Print vulnerabilities by severity
        vulnerabilities = [r for r in results if r.get('vulnerability')]

        if not vulnerabilities:
            print("\nNo vulnerabilities found.")
            return

        print("\nVULNERABILITIES FOUND:\n")

        for severity in ['Critical', 'High', 'Medium', 'Low', 'Info']:
            severity_results = [r for r in vulnerabilities if r.get('severity') == severity]
            if severity_results:
                print(f"\n{severity} Severity ({len(severity_results)}):")
                print("-" * 80)

                for result in severity_results:
                    print(f"\n  [{result.get('type', 'Unknown')}]")
                    print(f"  URL: {result.get('url', 'N/A')}")
                    if result.get('parameter'):
                        print(f"  Parameter: {result.get('parameter')}")
                    if result.get('payload'):
                        print(f"  Payload: {result.get('payload')[:100]}...")
                    if result.get('description'):
                        print(f"  Description: {result.get('description')}")

    def save_report(self, results: List[Dict[str, Any]], output_file: str, format: str = 'html'):
        """
        Save scan report

        Args:
            results: Scan results
            output_file: Output file path
            format: Report format (html, json, xml, txt)
        """
        scan_info = {
            'targets': self.config.get_targets(),
            'modules': self.config.modules,
            'total_requests': self.http_client.request_count,
        }

        success = self.report_generator.generate(results, output_file, format, scan_info)

        if success:
            logger.info(f"Report saved successfully: {output_file}")
        else:
            logger.error(f"Failed to save report: {output_file}")

    def cleanup(self):
        """Cleanup resources"""
        logger.info("Cleaning up scanner resources")
        self.http_client.close()

    def request_stop(self):
        """Request scan to stop gracefully"""
        logger.warning("Stop requested")
        self.stop_requested = True
        for scanner in self.scanners:
            scanner.request_stop()

import requests
import re
import random
import string
from typing import List, Dict, Any, Tuple

class WAFDetector:
    """
    Enhanced WAF detection inspired by wafw00f and identiwaf.
    Focuses on high-confidence signatures and multi-step verification to reduce false positives.
    """

    # High-confidence signatures. Headers are prioritized. Body signatures are for specific block pages.
    WAF_SIGNATURES = {
        'Cloudflare': {
            'headers': {'Server': r'cloudflare', 'CF-RAY': r'.*'},
            'cookies': {'__cfduid': r'.*', 'cf_clearance': r'.*'},
            'body': r'cloudflare-nginx|/cdn-cgi/|Attention Required! \| Cloudflare|Cloudflare Ray ID:|error code: 10\d{2}',
            'icon': 'fab fa-cloudflare'
        },
        'AWS WAF': {
            'headers': {'Server': r'awselb/\d\.\d', 'x-amz-cf-id': r'.*', 'x-amz-waf-': r'.*'},
            'cookies': {'aws-waf-token': r'.*'},
            'body': r'AWS\/WAF|x-amz-request-id|Request blocked\.',
            'icon': 'fab fa-aws'
        },
        'Imperva (Incapsula)': {
            'headers': {'X-Iinfo': r'.*'},
            'cookies': {'incap_ses_': r'.*', 'visid_incap_': r'.*'},
            'body': r'Powered by Incapsula|Request unsuccessful. Incapsula incident ID',
            'icon': 'fas fa-shield-alt'
        },
        'Akamai': {
            'headers': {'Server': r'AkamaiGHost', 'X-Akamai-Transformed': r'.*'},
            'cookies': {},
            'body': r'The requested URL "[^"]+" is unacceptable|Your request was blocked by Akamai',
            'icon': 'fas fa-shield-alt'
        },
        'Sucuri': {
            'headers': {'Server': r'Sucuri/Cloudproxy', 'X-Sucuri-ID': r'.*'},
            'cookies': {},
            'body': r'Access Denied - Sucuri Website Firewall|Protected by Sucuri',
            'icon': 'fas fa-shield-alt'
        },
        'Wordfence': {
            'headers': {},
            'cookies': {'wf-loginalerted': r'.*'},
            'body': r'Generated by Wordfence|A potentially unsafe operation has been detected in your request',
            'icon': 'fab fa-wordpress'
        },
        'ModSecurity': {
            'headers': {'Server': r'Mod_Security|mod_secure'},
            'cookies': {},
            'body': r'This error was generated by Mod_Security|mod_security|OWASP CRS',
            'icon': 'fas fa-shield-alt'
        },
        'F5 BIG-IP': {
            'headers': {'Server': r'BigIP|BIG-IP'},
            'cookies': {r'TS\w{10}': r'.*'},
            'body': r'The requested URL was rejected. Please consult with your administrator.',
            'icon': 'fas fa-shield-alt'
        },
        'Barracuda': {
            'headers': {},
            'cookies': {'barracuda_ci_session': r'.*'},
            'body': r'Barracuda Web Application Firewall',
            'icon': 'fas fa-shield-alt'
        },
        'Citrix NetScaler': {
            'headers': {},
            'cookies': {'citrix_ns_id': r'.*'},
            'body': r'Citrix.*Gateway|The page you are looking for is temporarily unavailable',
            'icon': 'fas fa-shield-alt'
        },
        'Wallarm': {
            'headers': {'Server': r'nginx-wallarm'},
            'cookies': {},
            'body': r'blocked by Wallarm|nginxg-wallarm',
            'icon': 'fas fa-shield-alt'
        },
        'Aliyun': {
            'headers': {},
            'cookies': {},
            'body': r'Sorry, your request has been blocked as it may cause potential threats to the server\'s security',
            'icon': 'fab fa-alibabacloud'
        }
    }

    @classmethod
    def analyze(cls, headers: Dict[str, str], response_text: str, url: str) -> Tuple[bool, List[Dict[str, Any]]]:
        """
        Passively analyze response headers, cookies, and content for WAF signatures.
        """
        findings = []
        detected_wafs = set()
        headers_lower = {k.lower(): v for k, v in headers.items()}

        for waf_name, data in cls.WAF_SIGNATURES.items():
            # 1. Check headers (highest confidence)
            for key, pattern in data.get('headers', {}).items():
                if key.lower() in headers_lower and re.search(pattern, headers_lower[key.lower()], re.IGNORECASE):
                    if waf_name not in detected_wafs:
                        reason = f"Header signature found: {key}: {headers_lower[key.lower()]}"
                        findings.append(cls._create_waf_finding(waf_name, url, reason))
                        detected_wafs.add(waf_name)
                        continue # Found WAF, move to next one

            if waf_name in detected_wafs:
                continue

            # 2. Check cookies
            for key, pattern in data.get('cookies', {}).items():
                if 'set-cookie' in headers_lower and re.search(f'{key}={pattern}', headers_lower['set-cookie'], re.IGNORECASE):
                     if waf_name not in detected_wafs:
                        reason = f"Cookie signature found: {key}"
                        findings.append(cls._create_waf_finding(waf_name, url, reason))
                        detected_wafs.add(waf_name)
                        continue
            
            if waf_name in detected_wafs:
                continue

            # 3. Check body (use only on specific blocking messages)
            # To reduce FPs, passive body scan is limited to attack responses.
            # This method is for non-attack responses, so we don't check body here.

        return len(findings) > 0, findings

    @classmethod
    def _create_waf_finding(cls, waf_name: str, url: str, reason: str, is_active: bool = False, payload: str = 'N/A') -> Dict[str, Any]:
        """Create a standardized WAF finding dictionary."""
        icon = cls.WAF_SIGNATURES.get(waf_name, {}).get('icon', 'fas fa-shield-alt')
        module_name = 'wafdetect'
        detector = 'WAFDetector.analyze' if not is_active else 'WAFDetector.active_detect'

        return {
            'module': module_name,
            'target': url,
            'vulnerability': f'WAF Detected: {waf_name}',
            'severity': 'Info',
            'parameter': 'N/A',
            'payload': payload,
            'evidence': reason,
            'request_url': url,
            'detector': detector,
            'response_snippet': reason,
            'method': 'GET',
            'passive_analysis': not is_active,
            'waf_name': waf_name,
            'icon': icon
        }

    @classmethod
    def active_detect(cls, url: str, headers: Dict[str, str], timeout: int) -> Tuple[bool, List[Dict[str, Any]]]:
        """
        Actively detect WAF by sending malicious-looking payloads and analyzing responses.
        Designed to minimize false positives by comparing against a baseline 404 response.
        """
        findings = []
        try:
            # 1. Get baseline "not found" response to avoid FP from generic server block pages
            random_path = ''.join(random.choices(string.ascii_lowercase, k=10))
            baseline_url = f"{url.rstrip('/')}/{random_path}.html"
            baseline_response = requests.get(baseline_url, timeout=timeout, headers=headers, verify=False)

            # 2. Define universal attack payloads
            attack_payloads = {
                'xss': "<script>alert('dominator_waf_test')</script>",
                'sqli': "' OR 1=1 --",
                'traversal': "../../../etc/passwd"
            }

            for attack_type, payload in attack_payloads.items():
                attack_url = f"{url}?waf_test_{attack_type}={payload}"
                print(f"    [WAF-DETECT] Sending active probe ({attack_type}): {attack_url}")
                
                attack_response = requests.get(attack_url, timeout=timeout, headers=headers, verify=False)
                
                # Compare fingerprints to reduce FPs. If attack response is same as baseline, it's not a WAF.
                if cls._get_response_fingerprint(attack_response.text) == cls._get_response_fingerprint(baseline_response.text):
                    continue

                # 3. Analyze response for blocking signatures
                # Check status code first
                if attack_response.status_code in [403, 406, 429, 501, 999]:
                    reason = f"Blocked with status code {attack_response.status_code} on {attack_type} probe"
                    findings.append(cls._create_waf_finding("Generic WAF", url, reason, is_active=True, payload=payload))
                    return True, findings # High confidence, exit early

                # Check body for WAF signatures and generic block messages
                response_lower = attack_response.text.lower()
                for waf_name, data in cls.WAF_SIGNATURES.items():
                    if re.search(data.get('body', ''), response_lower):
                        reason = f"Body signature found on {attack_type} probe: {data.get('body')}"
                        findings.append(cls._create_waf_finding(waf_name, url, reason, is_active=True, payload=payload))
                        return True, findings
                
                generic_block_keywords = ['blocked', 'forbidden', 'access denied', 'unauthorized', 'security incident']
                for keyword in generic_block_keywords:
                    if keyword in response_lower:
                        reason = f'Response body contains blocking keyword: "{keyword}" on {attack_type} probe'
                        findings.append(cls._create_waf_finding("Generic WAF", url, reason, is_active=True, payload=payload))
                        return True, findings

        except requests.exceptions.RequestException as e:
            print(f"    [WAF-DETECT] Error during active WAF detection: {e}")

        return False, findings
        
    @staticmethod
    def _get_response_fingerprint(text: str) -> str:
        """Create a simple fingerprint of a response body to compare pages."""
        # Normalize text: remove scripts, styles, and extra whitespace
        text = re.sub(r'<(script|style).*?>.*?</\1>', '', text, flags=re.DOTALL | re.IGNORECASE)
        text = re.sub(r'<.*?>', ' ', text) # Remove all tags
        text = re.sub(r'\s+', ' ', text).strip()
        # Return a hash of the first 500 characters to get a structural idea
        import hashlib
        return hashlib.sha1(text[:500].encode('utf-8', 'ignore')).hexdigest()

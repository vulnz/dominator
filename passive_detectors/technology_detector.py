"""
Passive technology detector
Identifies technologies used by analyzing HTTP headers and response content during crawling
"""

import re
import warnings
from typing import Dict, List, Tuple, Any

# Suppress Wappalyzer regex warnings globally for this module
warnings.filterwarnings("ignore", category=UserWarning, module="Wappalyzer")

class TechnologyDetector:
    """Passive technology detection"""
    
    @staticmethod
    def analyze(headers: Dict[str, str], response_text: str, url: str) -> Tuple[bool, List[Dict[str, Any]]]:
        """
        Passive technology detection
        
        How it works:
        1. Analyzes HTTP headers for characteristic values during crawling
        2. Searches HTML content for characteristic patterns (meta tags, comments, scripts)
        3. Identifies technology versions from specific markers
        4. Detects CMS, frameworks, libraries without additional requests
        
        Args:
            headers: HTTP response headers
            response_text: HTTP response content
            url: URL being analyzed
            
        Returns:
            Tuple[bool, List[Dict]]: (found_technologies, list_of_technologies)
        """
        technologies = []
        
        # Header analysis
        header_technologies = TechnologyDetector._analyze_headers(headers, url)
        technologies.extend(header_technologies)
        
        # Content analysis
        content_technologies = TechnologyDetector._analyze_content(response_text, url)
        technologies.extend(content_technologies)
        
        # CMS detection
        cms_technologies = TechnologyDetector._detect_cms(response_text, url)
        technologies.extend(cms_technologies)
        
        # JavaScript libraries
        js_technologies = TechnologyDetector._detect_javascript_libraries(response_text, url)
        technologies.extend(js_technologies)
        
        return len(technologies) > 0, technologies
    
    @staticmethod
    def _analyze_headers(headers: Dict[str, str], url: str) -> List[Dict[str, Any]]:
        """Analyze technologies from HTTP headers"""
        technologies = []
        
        header_patterns = {
            'Server': {
                r'Apache/(\d+\.\d+\.\d+)': {'name': 'Apache HTTP Server', 'category': 'Web Server'},
                r'nginx/(\d+\.\d+\.\d+)': {'name': 'Nginx', 'category': 'Web Server'},
                r'Microsoft-IIS/(\d+\.\d+)': {'name': 'Microsoft IIS', 'category': 'Web Server'},
                r'Apache': {'name': 'Apache HTTP Server', 'category': 'Web Server'},
                r'nginx': {'name': 'Nginx', 'category': 'Web Server'},
                r'IIS': {'name': 'Microsoft IIS', 'category': 'Web Server'}
            },
            'X-Powered-By': {
                r'PHP/(\d+\.\d+\.\d+)': {'name': 'PHP', 'category': 'Programming Language'},
                r'ASP\.NET': {'name': 'ASP.NET', 'category': 'Web Framework'},
                r'Express': {'name': 'Express.js', 'category': 'Web Framework'},
                r'Django/(\d+\.\d+\.\d+)': {'name': 'Django', 'category': 'Web Framework'}
            }
        }
        
        for header_name, patterns in header_patterns.items():
            header_value = headers.get(header_name, '')
            if not header_value:
                continue
                
            for pattern, tech_info in patterns.items():
                match = re.search(pattern, header_value, re.IGNORECASE)
                if match:
                    tech = {
                        'name': tech_info['name'],
                        'category': tech_info['category'],
                        'detection_method': 'HTTP Header',
                        'url': url,
                        'header': header_name,
                        'value': header_value
                    }
                    
                    if match.groups():
                        tech['version'] = match.group(1)
                    
                    technologies.append(tech)
        
        return technologies
    
    @staticmethod
    def _analyze_content(response_text: str, url: str) -> List[Dict[str, Any]]:
        """Analyze technologies from response content"""
        technologies = []
        
        content_patterns = {
            r'<meta name="generator" content="WordPress (\d+\.\d+\.\d+)"': {
                'name': 'WordPress', 'category': 'CMS'
            },
            r'<meta name="generator" content="Drupal (\d+)"': {
                'name': 'Drupal', 'category': 'CMS'
            },
            r'<meta name="generator" content="Joomla!"': {
                'name': 'Joomla!', 'category': 'CMS'
            },
            r'<!-- Generated by phpMyAdmin (\d+\.\d+\.\d+)': {
                'name': 'phpMyAdmin', 'category': 'Database Management'
            }
        }
        
        for pattern, tech_info in content_patterns.items():
            matches = re.finditer(pattern, response_text, re.IGNORECASE | re.DOTALL)
            for match in matches:
                tech = {
                    'name': tech_info['name'],
                    'category': tech_info['category'],
                    'detection_method': 'Content Analysis',
                    'url': url,
                    'pattern': pattern
                }
                
                if match.groups():
                    tech['version'] = match.group(1)
                
                technologies.append(tech)
        
        return technologies
    
    @staticmethod
    def _detect_cms(response_text: str, url: str) -> List[Dict[str, Any]]:
        """Detect CMS from file paths and content"""
        cms_indicators = []
        
        cms_patterns = {
            r'/wp-content/': {'name': 'WordPress', 'confidence': 'High'},
            r'/wp-includes/': {'name': 'WordPress', 'confidence': 'High'},
            r'/wp-admin/': {'name': 'WordPress', 'confidence': 'High'},
            r'/sites/default/files/': {'name': 'Drupal', 'confidence': 'High'},
            r'/administrator/': {'name': 'Joomla!', 'confidence': 'Medium'},
            r'/components/': {'name': 'Joomla!', 'confidence': 'Medium'}
        }
        
        for pattern, info in cms_patterns.items():
            if re.search(pattern, response_text, re.IGNORECASE):
                cms_indicators.append({
                    'name': info['name'],
                    'category': 'CMS',
                    'confidence': info['confidence'],
                    'detection_method': 'File Path Analysis',
                    'url': url,
                    'indicator': pattern
                })
        
        return cms_indicators
    
    @staticmethod
    def _detect_javascript_libraries(response_text: str, url: str) -> List[Dict[str, Any]]:
        """Detect JavaScript libraries and frameworks"""
        js_libraries = []
        
        js_patterns = {
            r'<script[^>]*src="[^"]*jquery[/-](\d+\.\d+\.\d+)[^"]*"': {
                'name': 'jQuery', 'category': 'JavaScript Library'
            },
            r'<script[^>]*src="[^"]*angular[/-](\d+\.\d+\.\d+)[^"]*"': {
                'name': 'AngularJS', 'category': 'JavaScript Framework'
            },
            r'<script[^>]*src="[^"]*react[/-](\d+\.\d+\.\d+)[^"]*"': {
                'name': 'React', 'category': 'JavaScript Library'
            },
            r'<script[^>]*src="[^"]*vue[/-](\d+\.\d+\.\d+)[^"]*"': {
                'name': 'Vue.js', 'category': 'JavaScript Framework'
            },
            r'<link[^>]*href="[^"]*bootstrap[/-](\d+\.\d+\.\d+)[^"]*\.css"': {
                'name': 'Bootstrap', 'category': 'CSS Framework'
            }
        }
        
        for pattern, info in js_patterns.items():
            matches = re.finditer(pattern, response_text, re.IGNORECASE)
            for match in matches:
                lib = {
                    'name': info['name'],
                    'category': info['category'],
                    'detection_method': 'Script Tag Analysis',
                    'url': url
                }
                
                if match.groups():
                    lib['version'] = match.group(1)
                
                js_libraries.append(lib)
        
        return js_libraries
